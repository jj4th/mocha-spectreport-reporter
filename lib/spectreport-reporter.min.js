var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

(function (global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(require("clsses/test")) : typeof define === "function" && define.amd ? define(["clsses/test"], factory) : factory(global.clsses_test);
})(this, function (clsses_test) {
    "use strict";

    var Stats = (function () {
        function Stats() {
            var tests = arguments[0] === undefined ? 0 : arguments[0];
            var pending = arguments[1] === undefined ? 0 : arguments[1];
            var failures = arguments[2] === undefined ? 0 : arguments[2];
            var duration = arguments[3] === undefined ? 0 : arguments[3];

            _classCallCheck(this, Stats);

            this.tests = tests;
            this.pending = pending;
            this.failures = failures;
            this.duration = duration;
            this.timeStart = null;
            this.timeStop = null;
        }

        _createClass(Stats, {
            add: {
                value: function add(stats) {
                    this.tests += stats.tests;
                    this.pending += stats.pending;
                    this.failures += stats.failures;
                }
            },
            start: {
                value: function start() {
                    this.timeStart = Date.now();
                }
            },
            stop: {
                value: function stop() {
                    this.timeStop = Date.now();
                    this.duration = Math.round((this.timeStop - this.timeStart) / 10) / 100;
                }
            }
        });

        return Stats;
    })();

    var classes_stats = Stats;

    var Test = function Test(test, status) {
        var _this = this;

        _classCallCheck(this, Test);

        this.status = status;
        this.title = test.title;
        this.fullTitle = test.fullTitle();
        this.duration = test.duration;

        // Make sure we only keep error properties
        Object.getOwnPropertyNames(test.err).forEach(function (key) {
            _this.error[key] = test.err[key];
        });
    };

    Test.TEST_PENDING = 2;
    Test.TEST_PASS = 1;
    Test.TEST_FAIL = 0;

    var classes_test = Test;

    var Suite = (function () {
        function Suite(suite, parent) {
            _classCallCheck(this, Suite);

            this.suites = [];
            this.tests = [];
            this.parent = parent;
            this.stats = new classes_stats();
        }

        _createClass(Suite, {
            addStats: {
                value: function addStats(stats) {
                    this.stats.add(stats);
                }
            },
            addSuite: {
                value: function addSuite(suite) {
                    if (!suite.hasTests()) {
                        return false;
                    }
                    this.suites.push(suite);
                    this.addStats(suite.stats);
                }
            },
            addTest: {
                value: function addTest(test) {
                    this.tests.push(test);
                    if (test.status === classes_test.TEST_PENDING) {
                        this.stats.pending++;
                    } else if (test.status === classes_test.TEST_PASS) {
                        this.stats.passes++;
                    } else if (test.status === classes_test.TEST_FAIL) {
                        this.stats.failures++;
                    }
                }
            },
            hasTests: {
                value: function hasTests() {
                    return this.tests.length > 1;
                }
            },
            start: {
                value: function start() {
                    this.stats.start();
                }
            },
            stop: {
                value: function stop() {
                    this.stats.stop();
                }
            },
            toJSON: {
                value: function toJSON() {
                    var clone = Object.assign({}, this);
                    clone.parent = undefined;
                    return clone;
                }
            }
        });

        return Suite;
    })();

    var classes_suite = Suite;

    /* jshint ignore:start */
    var fs = require("fs-extra");
    var util = require("util");

    /**
     * Module dependencies.
     */

    var Base = require("./node_modules/mocha/lib/reporters/base");
    var color = Base.color;

    var defaults = {
        screenshotDir: "test/screenshot",
        outputDir: "test/results",
        storyDir: "test/stories"
    };

    /**
     * Initialize a new `Spec` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    function Spec(runner, options) {
        var opts = options.reporterOptions || {};
        Base.call(this, runner);

        // Handle options and setup defaults
        opts.screenshotDir = opts.screenshotDir || defaults.screenshotDir;
        opts.outputDir = opts.outputDir || defaults.outputDir;
        opts.storyDir = opts.storyDir || defaults.storyDir;

        var self = this;
        var indents = 0;
        var curSuite = null;

        var storyPath = runner.suite.suites[0].file;

        var _util$splitPath = util.splitPath(storyPath, opts.storyDir, opts.outputDir);

        var _util$splitPath2 = _slicedToArray(_util$splitPath, 2);

        var outputPath = _util$splitPath2[0];
        var outputFilename = _util$splitPath2[1];

        function indent() {
            return Array(indents).join("  ");
        }

        // Handle console output if requested
        if (opts.console) {
            (function () {
                var failures = 0;
                runner.on("start", function () {
                    console.log();
                });

                runner.on("suite", function (suite) {
                    ++indents;
                    console.log(color("suite", "%s%s"), indent(), suite.title);
                });

                runner.on("suite end", function () {
                    --indents;
                    if (indents === 1) {
                        console.log();
                    }
                });

                runner.on("pending", function (test) {
                    var fmt = indent() + color("pending", "  - %s");
                    console.log(fmt, test.title);
                });

                runner.on("pass", function (test) {
                    if (test.speed === "fast") {
                        var fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s ");
                        console.log(fmt, test.title);
                    } else {
                        // jshint maxlen:150
                        var fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s ") + color(test.speed, "(%dms)");
                        console.log(fmt, test.title, test.duration);
                    }
                });

                runner.on("fail", function (test) {
                    console.log(indent() + color("fail", "  %d) %s"), ++failures, test.title);
                });

                runner.on("end", self.epilogue.bind(self));
            })();
        }

        // Take screenshots of failed tests if requested
        if (opts.screenshot) {
            runner.on("end", function () {
                util.screenshot(test, opts.screenshotDir);
            });
        }

        // Handle JSON output

        runner.on("suite", function (suite) {
            curSuite = new classes_suite(suite, curSuite);
            curSuite.start();
        });

        runner.on("suite end", function () {
            curSuite.end();

            if (curSuite.parent) {
                curSuite.parent.addSuite(curSuite);
                curSuite = curSuite.parent;
            }
        });

        runner.on("pending", function (test) {
            curSuite.addTest(new clsses_test(test, clsses_test.TEST_PENDING));
        });

        runner.on("pass", function (test) {
            curSuite.addTest(new clsses_test(test, clsses_test.TEST_PASS));
        });

        runner.on("fail", function (test) {
            curSuite.addTest(new clsses_test(test, clsses_test.TEST_FAIL));
        });

        runner.on("end", function () {
            curSuite.end(); // End the current suite again.

            var jsonFilename = outputFilename.replace(".js", ".json");
            fs.mkdirs(outputPath, function (err) {
                if (err) {
                    return console.error(err);
                }

                var stream = fs.createWriteStream(outputFilename + "/" + jsonFilename);
                stream.write(JSON.stringify(curSuite, null, 2));
                stream.end();
            });
        });
    }

    exports = module.exports = Spec;
    /* jshint ignore:end */
});
//# sourceMappingURL=./spectreport-reporter.min.js.map